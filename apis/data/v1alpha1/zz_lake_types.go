/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AwsObservation struct {
	ExternalID *string `json:"externalId,omitempty" tf:"external_id,omitempty"`

	IAMAssumedRoleArn *string `json:"iamAssumedRoleArn,omitempty" tf:"iam_assumed_role_arn,omitempty"`

	IAMUserArn *string `json:"iamUserArn,omitempty" tf:"iam_user_arn,omitempty"`
}

type AwsParameters struct {

	// +kubebuilder:validation:Required
	RoleID *string `json:"roleId" tf:"role_id,omitempty"`

	// +kubebuilder:validation:Required
	TestS3Bucket *string `json:"testS3Bucket" tf:"test_s3_bucket,omitempty"`
}

type CollectionsObservation struct {
	DataSources []DataSourcesObservation `json:"dataSources,omitempty" tf:"data_sources,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type CollectionsParameters struct {
}

type DataProcessRegionObservation struct {
}

type DataProcessRegionParameters struct {

	// +kubebuilder:validation:Required
	CloudProvider *string `json:"cloudProvider" tf:"cloud_provider,omitempty"`

	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`
}

type DataSourcesObservation struct {
	DefaultFormat *string `json:"defaultFormat,omitempty" tf:"default_format,omitempty"`

	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	StoreName *string `json:"storeName,omitempty" tf:"store_name,omitempty"`
}

type DataSourcesParameters struct {
}

type LakeObservation struct {
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	StorageDatabases []StorageDatabasesObservation `json:"storageDatabases,omitempty" tf:"storage_databases,omitempty"`

	StorageStores []StorageStoresObservation `json:"storageStores,omitempty" tf:"storage_stores,omitempty"`
}

type LakeParameters struct {

	// +kubebuilder:validation:Required
	Aws []AwsParameters `json:"aws" tf:"aws,omitempty"`

	// +kubebuilder:validation:Optional
	DataProcessRegion []DataProcessRegionParameters `json:"dataProcessRegion,omitempty" tf:"data_process_region,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`
}

type StorageDatabasesObservation struct {
	Collections []CollectionsObservation `json:"collections,omitempty" tf:"collections,omitempty"`

	MaxWildcardCollections *int64 `json:"maxWildcardCollections,omitempty" tf:"max_wildcard_collections,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Views []ViewsObservation `json:"views,omitempty" tf:"views,omitempty"`
}

type StorageDatabasesParameters struct {
}

type StorageStoresObservation struct {
	AdditionalStorageClasses []*string `json:"additionalStorageClasses,omitempty" tf:"additional_storage_classes,omitempty"`

	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	Delimiter *string `json:"delimiter,omitempty" tf:"delimiter,omitempty"`

	IncludeTags *bool `json:"includeTags,omitempty" tf:"include_tags,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type StorageStoresParameters struct {
}

type ViewsObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Pipeline *string `json:"pipeline,omitempty" tf:"pipeline,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type ViewsParameters struct {
}

// LakeSpec defines the desired state of Lake
type LakeSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LakeParameters `json:"forProvider"`
}

// LakeStatus defines the observed state of Lake.
type LakeStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LakeObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Lake is the Schema for the Lakes API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,mongodbatlasjet}
type Lake struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LakeSpec   `json:"spec"`
	Status            LakeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LakeList contains a list of Lakes
type LakeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Lake `json:"items"`
}

// Repository type metadata.
var (
	Lake_Kind             = "Lake"
	Lake_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Lake_Kind}.String()
	Lake_KindAPIVersion   = Lake_Kind + "." + CRDGroupVersion.String()
	Lake_GroupVersionKind = CRDGroupVersion.WithKind(Lake_Kind)
)

func init() {
	SchemeBuilder.Register(&Lake{}, &LakeList{})
}
